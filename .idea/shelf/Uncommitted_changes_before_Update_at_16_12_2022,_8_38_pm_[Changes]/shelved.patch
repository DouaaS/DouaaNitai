Index: avl_template_new.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#username - complete info\r\n#id1      - complete info \r\n#name1    - complete info \r\n#id2      - complete info\r\n#name2    - complete info  \r\n\r\n\r\n\r\n\"\"\"A class represnting a node in an AVL tree\"\"\"\r\n\r\nclass AVLNode(object):\r\n\t\"\"\"Constructor, you are allowed to add more fields.\r\n\r\n\t@type value: str\r\n\t@param value: data of your node\r\n\t\"\"\"\r\n\tdef __init__(self, value):\r\n\t\tself.value = value\r\n\t\tself.left = None\r\n\t\tself.right = None\r\n\t\tself.parent = None\r\n\t\tself.height = -1 # Balance factor\r\n\t\tself.size = 1\r\n\r\n\r\n\t\"\"\"returns the left child\r\n\t@rtype: AVLNode\r\n\t@returns: the left child of self, None if there is no left child\r\n\t\"\"\"\r\n\tdef getLeft(self):\r\n\t\treturn self.left\r\n\r\n\r\n\t\"\"\"returns the right child\r\n\r\n\t@rtype: AVLNode\r\n\t@returns: the right child of self, None if there is no right child\r\n\t\"\"\"\r\n\tdef getRight(self):\r\n\t\treturn self.right\r\n\r\n\t\"\"\"returns the parent \r\n\r\n\t@rtype: AVLNode\r\n\t@returns: the parent of self, None if there is no parent\r\n\t\"\"\"\r\n\tdef getParent(self):\r\n\t\treturn self.parent\r\n\r\n\t\"\"\"return the value\r\n\r\n\t@rtype: str\r\n\t@returns: the value of self, None if the node is virtual\r\n\t\"\"\"\r\n\tdef getValue(self):\r\n\t\treturn self.value\r\n\r\n\t\"\"\"returns the height\r\n\r\n\t@rtype: int\r\n\t@returns: the height of self, -1 if the node is virtual\r\n\t\"\"\"\r\n\tdef getHeight(self):\r\n\t\treturn self.height\r\n\r\n\t\"\"\"sets left child\r\n\r\n\t@type node: AVLNode\r\n\t@param node: a node\r\n\t\"\"\"\r\n\tdef setLeft(self, node):\r\n\t\tself.left = node\r\n\r\n\t\"\"\"sets right child\r\n\r\n\t@type node: AVLNode\r\n\t@param node: a node\r\n\t\"\"\"\r\n\tdef setRight(self, node):\r\n\t\tself.right = node\r\n\r\n\t\"\"\"sets parent\r\n\r\n\t@type node: AVLNode\r\n\t@param node: a node\r\n\t\"\"\"\r\n\tdef setParent(self, node):\r\n\t\tself.parent = node\r\n\r\n\t\"\"\"sets value\r\n\r\n\t@type value: str\r\n\t@param value: data\r\n\t\"\"\"\r\n\tdef setValue(self, value):\r\n\t\tself.value = value\r\n\r\n\t\"\"\"sets the balance factor of the node\r\n\r\n\t@type h: int\r\n\t@param h: the height\r\n\t\"\"\"\r\n\tdef setHeight(self, h):\r\n\t\tself.height = h\r\n\r\n\t\"\"\"returns whether self is not a virtual node \r\n\r\n\t@rtype: bool\r\n\t@returns: False if self is a virtual node, True otherwise.\r\n\t\"\"\"\r\n\tdef isRealNode(self):\r\n\t\treturn self.value != \"VIRTUAL\"\r\n\r\n\r\n\t\"\"\"\r\n\tReturns LEFT if curr node is left child of its parent, RIGHT if right child, and ROOT else.\r\n\t\"\"\"\r\n\tdef childDirection(self):\r\n\t\tif self.parent == None:\r\n\t\t\treturn \"ROOT\"\r\n\t\telif self.getParent().getLeft() == self:\r\n\t\t\treturn \"LEFT\"\r\n\t\telse:\r\n\t\t\treturn \"RIGHT\"\r\n\r\n\tdef getSize(self):\r\n\t\treturn self.size\r\n\r\n\tdef setSize(self,s):\r\n\t\tself.size = s\r\n\r\n\r\n\r\n\r\n\r\n\"\"\"\r\nA class implementing the ADT list, using an AVL tree.\r\n\"\"\"\r\n\r\nclass AVLTreeList(object):\r\n\r\n\r\n\t\"\"\"\r\n\tConstructor, you are allowed to add more fields.\r\n\r\n\t\"\"\"\r\n\tdef __init__(self):\r\n\t\tself.size = 0\r\n\t\tself.root = None\r\n\t\tself.VIRTUALNODE = AVLNode(\"VIRTUAL\")\r\n\t\tself.VIRTUALNODE.setSize(0)\r\n\r\n\r\n\r\n\t\"\"\"returns whether the list is empty\r\n\r\n\t@rtype: bool\r\n\t@returns: True if the list is empty, False otherwise\r\n\t\"\"\"\r\n\tdef empty(self):\r\n\t\treturn self.size == 0\r\n\r\n\r\n\t\"\"\"retrieves the value of the i'th item in the list\r\n\r\n\t@type i: int\r\n\t@pre: 0 <= i < self.length()\r\n\t@param i: index in the list\r\n\t@rtype: str\r\n\t@returns: the the value of the i'th item in the list\r\n\t\"\"\"\r\n\tdef retrieve(self, i):\r\n\t\tdef retrieve_rec(node,i):\r\n\t\t\tleft_subtree_size = 0\r\n\t\t\tif node.getLeft().isRealNode():\r\n\t\t\t\tleft_subtree_size = node.getLeft().getSize()\r\n\t\t\tif i==left_subtree_size:\r\n\t\t\t\treturn node\r\n\t\t\telse:\r\n\t\t\t\tif i<node.getLeft().getSize():\r\n\t\t\t\t\tind = i\r\n\t\t\t\t\treturn retrieve_rec(node.getLeft(), ind)\r\n\t\t\t\telse:\r\n\t\t\t\t\tind = i-node.getLeft().getSize()-1\r\n\t\t\t\t\treturn retrieve_rec(node.getRight(),ind)\r\n\r\n\t\tif i > self.size:\r\n\t\t\treturn None\r\n\t\telse:\r\n\t\t\treturn retrieve_rec(self.root,i)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t\"\"\"inserts val at position i in the list\r\n\r\n\t@type i: int\r\n\t@pre: 0 <= i <= self.length()\r\n\t@param i: The intended index in the list to which we insert val\r\n\t@type val: str\r\n\t@param val: the value we inserts\r\n\t@rtype: list\r\n\t@returns: the number of rebalancing operation due to AVL rebalancing\r\n\t\"\"\"\r\n\tdef insert(self, i, val):\r\n\t\tnew_node = AVLNode(val)\r\n\t\tlow_node = new_node\r\n\t\tnew_node.setRight(self.VIRTUALNODE)\r\n\t\tnew_node.setLeft(self.VIRTUALNODE)\r\n\t\tif self.size == 0 and i==0:\r\n\t\t\tself.root = new_node\r\n\t\t\tself.size=1\r\n\t\telif i == 0:\r\n\t\t\ttmp = self.root\r\n\t\t\tself.root = new_node\r\n\t\t\tnew_node.setRight(tmp)\r\n\t\t\ttmp.setParent(new_node)\r\n\t\t\tself.size += 1\r\n\r\n\t\telif self.size == i:\r\n\t\t\tparent = self.getMaxNode()\r\n\t\t\tparent.setRight(new_node)\r\n\t\t\tnew_node.setParent(parent)\r\n\t\t\tself.size += 1\r\n\t\telse:\r\n\t\t\tnode = self.retrieve(i)\r\n\t\t\tif not (node.getLeft().isRealNode()):\r\n\t\t\t\t# node.setRight(new_node)\r\n\t\t\t\t# new_node.setParent(node)\r\n\t\t\t\tnode.setLeft(new_node)\r\n\t\t\t\tnew_node.setParent(node)\r\n\t\t\telse:\r\n\t\t\t\t# sucessor = self.getSucessor(node)\r\n\t\t\t\t# succ_curr_left = sucessor.getLeft()\r\n\t\t\t\t# sucessor.setLeft(new_node)\r\n\t\t\t\t# new_node.setParent(succ_curr_left)\r\n\t\t\t\tpredecessor = self.getPredecessor(node)\r\n\t\t\t\tif predecessor == None:\r\n\t\t\t\t\ttmp = self.root\r\n\t\t\t\t\tself.root = new_node\r\n\t\t\t\t\tnew_node.setRight(tmp)\r\n\t\t\t\t\ttmp.setParent(new_node)\r\n\t\t\t\t\tlow_node = tmp\r\n\t\t\t\t\tself.size += 1\r\n\t\t\t\telse:\r\n\t\t\t\t\tpredecessor_curr_right = predecessor.getRight()\r\n\t\t\t\t\tpredecessor.setRight(new_node)\r\n\t\t\t\t\tnew_node.setParent(predecessor)\r\n\r\n\t\trotations_cnt = self.rebalance(low_node)\r\n\t\tself.updateHeight(low_node)\r\n\t\tself.updateSize(low_node)\r\n\t\treturn rotations_cnt\r\n\r\n\r\n\t\"\"\"deletes the i'th item in the list\r\n\r\n\t@type i: int\r\n\t@pre: 0 <= i < self.length()\r\n\t@param i: The intended index in the list to be deleted\r\n\t@rtype: int\r\n\t@returns: the number of rebalancing operation due to AVL rebalancing\r\n\t\"\"\"\r\n\tdef delete(self, i):\r\n\t\tnode = self.retrieve(i)\r\n\t\tparent = node.getParent()\r\n\t\tleft = node.getLeft()\r\n\t\tright = node.getRight()\r\n\t\trotations_cnt = 0\r\n\t\tif left.isRealNode() and right.isRealNode():\r\n\t\t\tpred = node.getPredecessor() \t\t\t\t#if node has right son, its predecessor is the max node in the left sub tree (no right sons)\r\n\t\t\tpred_left_child = pred.getLeft()\r\n\t\t\tpred_parent = pred.getParent()\r\n\r\n\t\t\tif pred_left_child.isRealNode():\r\n\t\t\t\tpred_left_child.setParent(pred_parent)\r\n\t\t\t\tpred_parent.setRight(pred_left_child)\r\n\t\t\tpred.setLeft(node.getLeft())\r\n\t\t\tpred.setRight(node.getRight())\r\n\t\t\tpred.setParent(node.getParent())\r\n\t\t\trotations_cnt = self.rebalance(pred_parent)\r\n\r\n\t\t\tself.updateSize(pred_left_child)\r\n\r\n\t\telse:\r\n\t\t\tdirection = node.childDirection()\r\n\t\t\tnode_is_left_child = direction == 'LEFT'\r\n\t\t\tnode_child = self.VIRTUALNODE              #the deafult is virtual, will change if the node has one son and wouldn't if not\r\n\r\n\t\t\tif left.isRealNode():\r\n\t\t\t\tnode_child = left\r\n\t\t\telif right.isRealNode():\r\n\t\t\t\tnode_child = right\r\n\r\n\r\n\t\t\tif node_is_left_child:\r\n\t\t\t\tparent.setLeft(node_child)\r\n\t\t\telse:\r\n\t\t\t\tparent.setRight(node_child)\r\n\t\t\tparent.setSize(parent.getSize()-1)\r\n\t\t\tif node_child.isRealNode():\r\n\t\t\t\tnode_child.setParent(parent)\r\n\t\t\t\trotations_cnt = self.rebalance(node_child)\r\n\t\t\t\tself.updateSize(node_child)\r\n\r\n\r\n\t\t\telse:\r\n\t\t\t\trotations_cnt = self.rebalance(parent)\r\n\t\t\t\tself.updateSize(parent)\r\n\r\n\t\treturn rotations_cnt\r\n\r\n\r\n\r\n\r\n\r\n\t\"\"\"returns the value of the first item in the list\r\n\r\n\t@rtype: str\r\n\t@returns: the value of the first item, None if the list is empty\r\n\t\"\"\"\r\n\tdef first(self):\r\n\t\treturn None\r\n\r\n\t\"\"\"returns the value of the last item in the list\r\n\r\n\t@rtype: str\r\n\t@returns: the value of the last item, None if the list is empty\r\n\t\"\"\"\r\n\tdef last(self):\r\n\t\treturn None\r\n\r\n\t\"\"\"returns an array representing list \r\n\r\n\t@rtype: list\r\n\t@returns: a list of strings representing the data structure\r\n\t\"\"\"\r\n\tdef listToArray(self):\r\n\t\treturn None\r\n\r\n\t\"\"\"returns the size of the list \r\n\r\n\t@rtype: int\r\n\t@returns: the size of the list\r\n\t\"\"\"\r\n\tdef length(self):\r\n\t\treturn None\r\n\r\n\t\"\"\"sort the info values of the list\r\n\r\n\t@rtype: list\r\n\t@returns: an AVLTreeList where the values are sorted by the info of the original list.\r\n\t\"\"\"\r\n\tdef sort(self):\r\n\t\treturn None\r\n\r\n\t\"\"\"permute the info values of the list \r\n\r\n\t@rtype: list\r\n\t@returns: an AVLTreeList where the values are permuted randomly by the info of the original list. ##Use Randomness\r\n\t\"\"\"\r\n\tdef permutation(self):\r\n\t\treturn None\r\n\r\n\t\"\"\"concatenates lst to self\r\n\r\n\t@type lst: AVLTreeList\r\n\t@param lst: a list to be concatenated after self\r\n\t@rtype: int\r\n\t@returns: the absolute value of the difference between the height of the AVL trees joined\r\n\t\"\"\"\r\n\tdef concat(self, lst):\r\n\t\treturn None\r\n\r\n\t\"\"\"searches for a *value* in the list\r\n\r\n\t@type val: str\r\n\t@param val: a value to be searched\r\n\t@rtype: int\r\n\t@returns: the first index that contains val, -1 if not found.\r\n\t\"\"\"\r\n\tdef search(self, val):\r\n\t\treturn None\r\n\r\n\r\n\r\n\t\"\"\"returns the root of the tree representing the list\r\n\r\n\t@rtype: AVLNode\r\n\t@returns: the root, None if the list is empty\r\n\t\"\"\"\r\n\tdef getRoot(self):\r\n\t\treturn None\r\n\r\n\r\n\t\"\"\"\r\n\trotate right the edge between child node and parent node, and update heights\r\n\t@rtype: child node left node, and parent node as right node\r\n\t@returns: None\r\n\t\"\"\"\r\n\tdef rightRotation(self, child_node,parent_node):\r\n\t\tgrand_parent = parent_node.getParent()\r\n\t\tparent_direction = parent_node.childDirection()\r\n\t\tis_parent_left_child = parent_direction == \"LEFT\"\r\n\t\tis_parent_right_child = parent_direction == \"RIGHT\"\r\n\t\tis_parent_root = parent_direction == \"ROOT\"\r\n\r\n\r\n\t\tparent_node.setLeft(child_node.getRight())\r\n\t\tparent_node.getLeft().getParent().setParent(parent_node)\r\n\r\n\t\tif is_parent_left_child:\r\n\t\t\tgrand_parent.setLeft(child_node)\r\n\t\telif is_parent_right_child:\r\n\t\t\tgrand_parent.setRight(child_node)\r\n\t\tif not is_parent_root:\r\n\t\t\tchild_node.setParent(grand_parent)\r\n\t\telse:\r\n\t\t\tchild_node.setParent(None)\r\n\t\t\tself.root = child_node\r\n\r\n\t\tchild_node.setRight(parent_node)\r\n\t\tparent_node.setParent(child_node)\r\n\r\n\t\tchild_node.setHeight(child_node.getHeight()+1)\r\n\t\tparent_node.setHeight(parent_node.getHeight()-1)\r\n\r\n\r\n\t\"\"\"\r\n\trotate right the edge between child node and parent node, and update heights\r\n\t@rtype: child node right node, and parent node as left node\r\n\t@returns: None\r\n\t\"\"\"\r\n\tdef leftRotation(self, child_node, parent_node):\r\n\t\tgrand_parent = parent_node.getParent()\r\n\t\tparent_direction = parent_node.childDirection()\r\n\t\tis_parent_left_child = parent_direction == \"LEFT\"\r\n\t\tis_parent_right_child = parent_direction == \"RIGHT\"\r\n\t\tis_parent_root = parent_direction == \"ROOT\"\r\n\r\n\t\tparent_node.setRight(child_node.getLeft())\r\n\t\tparent_node.getRight().setParent(parent_node)\r\n\r\n\t\tif is_parent_left_child:\r\n\t\t\tgrand_parent.setLeft(child_node)\r\n\t\telif is_parent_right_child:\r\n\t\t\tgrand_parent.setRight(child_node)\r\n\t\tif not is_parent_root:\r\n\t\t\tchild_node.setParent(grand_parent)\r\n\t\telse:\r\n\t\t\tchild_node.setParent(None)\r\n\t\t\tself.root = child_node\r\n\r\n\t\tchild_node.setLeft(parent_node)\r\n\t\tparent_node.setParent(child_node)\r\n\r\n\t\tchild_node.setHeight(child_node.getHeight()+1)\r\n\t\tparent_node.setHeight(parent_node.getHeight()-1)\r\n\r\n\r\n\r\n\t\"\"\" \r\n\t@rtype: AVLNode\r\n\t@returns: if index(node) = i, return the node in index i-1\r\n\t\"\"\"\r\n\tdef getPredecessor(self,node):\r\n\t\tpredecessor = None\r\n\t\tcurr = None\r\n\t\tif node.getLeft().isRealNode():\r\n\t\t\tcurr = node.getLeft()\r\n\t\t\twhile curr.getRight().isRealNode():\r\n\t\t\t\tcurr = curr.getRight()\r\n\t\t\tpredecessor = curr\r\n\t\telse:\r\n\t\t\tcurr = node\r\n\t\t\twhile curr.getParent() != None:\r\n\t\t\t\tcurr_direction = curr.childDirection()\r\n\t\t\t\tif curr_direction == \"LEFT\":\r\n\t\t\t\t\tpredecessor = node.getParent()\r\n\t\t\t\t\tbreak\r\n\t\t\t\telse:\r\n\t\t\t\t\tcurr = curr.getParent()\r\n\t\treturn predecessor\r\n\r\n\r\n\t\"\"\" \r\n\t@rtype: AVLNode\r\n\t@returns: if index(node) = i, return the node in index i-1\r\n\t\"\"\"\r\n\tdef getSucessor(self,node):\r\n\t\tsucessor = None\r\n\t\tcurr = None\r\n\t\tif node.getRight().isRealNode():\r\n\t\t\tcurr = node.getRight()\r\n\t\t\twhile curr.getLeft().isRealNode:\r\n\t\t\t\tcurr = curr.getLeft()\r\n\t\t\tsucessor = curr\r\n\t\telse:\r\n\t\t\tcurr = node\r\n\t\t\twhile curr.getParent() != None:\r\n\t\t\t\tcurr_direction = curr.childDirection()\r\n\t\t\t\tif curr_direction == \"RIGHT\":\r\n\t\t\t\t\tsucessor = node.getParent()\r\n\t\t\t\t\tbreak\r\n\t\t\t\telse:\r\n\t\t\t\t\tcurr = curr.getParent()\r\n\t\treturn sucessor\r\n\r\n\t\"\"\"\r\n\ttraverse the tree bottom-up, and update the height of each subtree, all the way to the root\r\n\t@rtype: AVLNode, the lowest one in the tree that we need to changes\r\n\t@returns: None\r\n\t\"\"\"\r\n\tdef updateHeight(self, lowest_node):\r\n\t\tcurr = lowest_node\r\n\t\tif curr == self.VIRTUALNODE:\r\n\t\t\tcurr = curr.getParent()\r\n\t\twhile curr != None:\r\n\t\t\tcurr.setHeight(max(curr.getLeft().getHeight(),curr.getRight().getHeight()) + 1)\r\n\t\t\tcurr = curr.getParent()\r\n\r\n\t\"\"\"\r\n\ttraverse the tree bottom-up, and update the size of each subtree, all the way to the root \r\n\t@rtype: AVLNode, the lowest one in the tree that we need to changes\r\n\t@returns: None\r\n\t\"\"\"\r\n\tdef updateSize(self, lowest_node):\r\n\t\tcurr = lowest_node\r\n\t\tif curr == self.VIRTUALNODE:\r\n\t\t\tcurr = curr.getParent()\r\n\t\twhile curr != None:\r\n\t\t\tcurr.size = 1 + curr.getLeft().getSize() + curr.getRight().getSize()\r\n\t\t\tcurr = curr.getParent()\r\n\r\n\t\"\"\" \r\n\t@rtype: AVLTree\r\n\t@returns: int, the height diff between node left subtree and node right subtree\r\n\t\"\"\"\r\n\r\n\tdef getBfs(self,node):\r\n\t\tleft_tree_height = node.getLeft().getHeight()\r\n\t\tright_tree_height = node.getRight().getHeight()\r\n\t\tbfs = left_tree_height - right_tree_height\r\n\t\treturn bfs\r\n\r\n\t\"\"\"\r\n\trebalance the tree, and update each changed node height\r\n\t@rtype: AVLTree\r\n\t@returns: rotations count\r\n\t\"\"\"\r\n\r\n\tdef rebalance(self,lowest_node):\r\n\t\tself.updateHeight(lowest_node)\r\n\t\tcnt = 0\r\n\t\tcurr = lowest_node\r\n\t\tif curr == self.VIRTUALNODE:\r\n\t\t\tcurr = curr.getParent()\r\n\t\twhile curr!=None:\r\n\t\t\tbfs = self.getBfs(curr)\r\n\t\t\tif -1<=bfs<=1:\r\n\t\t\t\tcurr = curr.getParent()\r\n\t\t\t\tcontinue\r\n\t\t\tif bfs <= -2:\r\n\t\t\t\tright_child = curr.getRight()\r\n\t\t\t\tright_child_bfs = self.getBfs(right_child)\r\n\t\t\t\tif -1 <= right_child_bfs <= 0:\r\n\t\t\t\t\tself.leftRotation(right_child, curr)\r\n\t\t\t\t\tcnt += 1\r\n\t\t\t\t\t# curr.setHeight(curr.getHeight()-1)\r\n\t\t\t\t\t# right_child.setHeight(right_child.getHeight()+1)\r\n\r\n\t\t\t\telif right_child_bfs == 1:\r\n\t\t\t\t\tright_child_left_child = right_child.getLeft()\r\n\t\t\t\t\tself.rightRotation(right_child_left_child,right_child)\r\n\t\t\t\t\tself.leftRotation(right_child_left_child, curr)\r\n\t\t\t\t\tself.updateSize(right_child)\r\n\r\n\t\t\t\t\tcnt += 2\r\n\r\n\t\t\tif bfs >= 2:\r\n\t\t\t\tleft_child = curr.getLeft()\r\n\t\t\t\tleft_child_bfs = self.getBfs(left_child)\r\n\t\t\t\tif left_child_bfs == -1:\r\n\t\t\t\t\tleft_child_right_child = left_child.getRight()\r\n\t\t\t\t\tself.leftRotation(left_child_right_child, left_child)\r\n\t\t\t\t\tself.rightRotation(left_child_right_child, curr)\r\n\t\t\t\t\tself.updateSize(left_child)\r\n\r\n\t\t\t\t\tcnt += 2\r\n\t\t\t\telif 0<=left_child_bfs <= 1:\r\n\t\t\t\t\tself.rightRotation(left_child, curr)\r\n\t\t\t\t\tcnt +=1\r\n\t\t\tself.updateHeight(curr)\r\n\t\t\tself.updateSize(curr)\r\n\r\n\t\t\tcurr = curr.getParent()\r\n\t\treturn cnt\r\n\r\n\tdef getMaxNode(self):\r\n\t\tdef maxNodeRec(node):\r\n\t\t\tcurr = node\r\n\t\t\twhile curr.getRight().isRealNode():\r\n\t\t\t\tcurr = curr.getRight()\r\n\t\t\treturn curr\r\n\t\treturn maxNodeRec(self.root)\r\n\r\n\tdef inorderPrint(self):\r\n\t\tdef inorderPrintRec(node):\r\n\t\t\tif not node.isRealNode():\r\n\t\t\t\treturn\r\n\t\t\telse:\r\n\t\t\t\tinorderPrintRec(node.getLeft())\r\n\t\t\t\tprint('val: ' + node.getValue() + ' height: ' + str(node.getHeight()) + ' size: ' + str(node.getSize()) + ' left: ' + node.getLeft().getValue() + ' right: ' + node.getRight().getValue())\r\n\t\t\t\tinorderPrintRec(node.getRight())\r\n\t\tinorderPrintRec(self.root)\r\n\t\tprint(\"tree size \" + str(self.size))\r\n\r\n\r\ndef test():\r\n\tavl = AVLTreeList()\r\n\tavl.insert(0,'0')\r\n\tavl.insert(1,'1')\r\n\tavl.insert(0,'2')\r\n\tavl.insert(1,'3')\r\n\tavl.insert(0,'4')\r\n\r\n\tnode = avl.retrieve(3).getValue()\r\n\tprint(node)\r\n\t#\r\n\t# avl.insert(1,'1')\r\n\t# avl.insert(2,'2')\r\n\t# n = avl.retrieve(2)\r\n\t# avl.insert(2,'3')\r\n\t# avl.insert(0,'4')\r\n\t# avl.insert(1,'5')\r\n\tavl.inorderPrint()\r\n\tavl.delete(0)\r\n\r\n\r\n\t# avl.inorderPrint()\r\n\r\ntest()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/avl_template_new.py b/avl_template_new.py
--- a/avl_template_new.py	(revision c4fc9153fa6c4c221803945cf0f19debce81ca16)
+++ b/avl_template_new.py	(date 1671205901430)
@@ -1,5 +1,5 @@
-#username - complete info
-#id1      - complete info 
+#username - douaasatel
+#id1      - 206360521
 #name1    - complete info 
 #id2      - complete info
 #name2    - complete info  
